{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE BangPatterns #-}
module KAT_Ed448 ( tests ) where

import           Crypto.Error
import qualified Crypto.PubKey.Ed448 as Ed448
import           Imports

data Vec = Vec
    { vecSec :: ByteString
    , vecPub :: ByteString
    , vecMsg :: ByteString
    , vecSig :: ByteString
    } deriving (Show,Eq)

vec1 = Vec
    { vecSec = "\xc4\xea\xb0\x5d\x35\x70\x07\xc6\x32\xf3\xdb\xb4\x84\x89\x92\x4d\x55\x2b\x08\xfe\x0c\x35\x3a\x0d\x4a\x1f\x00\xac\xda\x2c\x46\x3a\xfb\xea\x67\xc5\xe8\xd2\x87\x7c\x5e\x3b\xc3\x97\xa6\x59\x94\x9e\xf8\x02\x1e\x95\x4e\x0a\x12\x27\x4e"
    , vecPub = "\x43\xba\x28\xf4\x30\xcd\xff\x45\x6a\xe5\x31\x54\x5f\x7e\xcd\x0a\xc8\x34\xa5\x5d\x93\x58\xc0\x37\x2b\xfa\x0c\x6c\x67\x98\xc0\x86\x6a\xea\x01\xeb\x00\x74\x28\x02\xb8\x43\x8e\xa4\xcb\x82\x16\x9c\x23\x51\x60\x62\x7b\x4c\x3a\x94\x80"
    , vecMsg = "\x03"
    , vecSig = "\x26\xb8\xf9\x17\x27\xbd\x62\x89\x7a\xf1\x5e\x41\xeb\x43\xc3\x77\xef\xb9\xc6\x10\xd4\x8f\x23\x35\xcb\x0b\xd0\x08\x78\x10\xf4\x35\x25\x41\xb1\x43\xc4\xb9\x81\xb7\xe1\x8f\x62\xde\x8c\xcd\xf6\x33\xfc\x1b\xf0\x37\xab\x7c\xd7\x79\x80\x5e\x0d\xbc\xc0\xaa\xe1\xcb\xce\xe1\xaf\xb2\xe0\x27\xdf\x36\xbc\x04\xdc\xec\xbf\x15\x43\x36\xc1\x9f\x0a\xf7\xe0\xa6\x47\x29\x05\xe7\x99\xf1\x95\x3d\x2a\x0f\xf3\x34\x8a\xb2\x1a\xa4\xad\xaf\xd1\xd2\x34\x44\x1c\xf8\x07\xc0\x3a\x00"
    }

testVec :: String -> Vec -> [TestTree]
testVec s vec =
    [ testCase (s ++ " gen publickey") (pub @=? Ed448.toPublic sec)
    , testCase (s ++ " gen secretkey") (Ed448.generateSecretKey *> pure ())
    , testCase (s ++ " gen signature") (sig @=? Ed448.sign sec pub (vecMsg vec))
    , testCase (s ++ " verify sig") (True @=? Ed448.verify pub (vecMsg vec) sig)
    ]
  where
        !sig = throwCryptoError $ Ed448.signature (vecSig vec)
        !pub = throwCryptoError $ Ed448.publicKey (vecPub vec)
        !sec = throwCryptoError $ Ed448.secretKey (vecSec vec)

katTests :: [TestTree]
katTests = testVec "vec 1" vec1

tests = testGroup "Ed448"
    [ testGroup "KATs" katTests
    ]
